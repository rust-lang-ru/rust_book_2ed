## Hello, World!

Итак, когда Rust уже установлен, можно приступать к написанию вашей первой программы.
[По традиции], (а точнее с 1978 года, когда вышла в свет первое издания [книги о Си])
напишем небольшую программу, которая напечатает "Привет, Мир!" в строке вывода.

[По традиции]: https://ru.wikipedia.org/wiki/Hello,_world!
[книги о Си]: https://ru.wikipedia.org/wiki/%D0%AF%D0%B7%D1%8B%D0%BA_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F_%D0%A1%D0%B8_(%D0%BA%D0%BD%D0%B8%D0%B3%D0%B0)

> Примечание: Эта книга предполагает базовое знакомство с командной строкой.
> Сам Rust не предъявляет особых требований к редактированию, инструментарию
> или месту хранения кода, поэтому, если вы предпочитаете IDE
> командной строке - используйте свою любимую интергрированную среду разработки.

### Создание директории проекта

Первым делом создадим директорию для хранения исходных кодов Rust. Это, конечно, не
обязательное условие для программировании на Rust, но для удобства нашей работы
это будут лучшим решением.

Итак, приступим. Создадим папку *projects* и далее будем создавать проекты Rust
в этой директории. Для этого откроем эмулятор терминала и введём следующие команды:

Linux и Mac:

```shell
$ mkdir ~/projects
$ cd ~/projects
$ mkdir hello_world
$ cd hello_world
```

Windows CMD:

```cmd
> mkdir %USERPROFILE%\projects
> cd %USERPROFILE%\projects
> mkdir hello_world
> cd hello_world
```

Windows PowerShell:

```powershell
> mkdir $env:USERPROFILE\projects
> cd $env:USERPROFILE\projects
> mkdir hello_world
> cd hello_world
```

### Написание и запуск первой программы

Далее, создадим текстовый файл и назовём его *main.rs*. Все файлы исходного кода Rust имеют расширение *.rs*. Если в имени файла несколько слов, используйте нижнее
подчёркивание для их разделения. Например, пишите *hello_world.rs* вместо
*helloworld.rs*.

Теперь откроем файл*main.rs* для редактирования и введём следующие сроки кода:

<span class="filename">Имя файла: main.rs</span>

```rust
fn main() {
    println!("Привет, Мир!");
}
```

Сохраним файл и вернёмся в окно терминала. На Linux или macOS, введём
следующие команды:

```shell
$ rustc main.rs
$ ./main
Привет, Мир!
```

На Windows, используем `.\main.exe` вместо `./main`:

```cmd
> rustc main.rs
> .\main.exe
Привет, Мир!
```

Независимо от вашей операционной системы, вы должны увидеть строку `Привет, мир!`,
напечатанную в терминале. Поздравляем, если получилось! Вы официально написали программу на Rust. Вы Rust программист! Добро пожаловать!

### Структура программы Rust

Теперь, давайте разберёмся, как же работает ваша новая "Привет, Мир!" программа.
Первое, разберем исходный код:

```rust
fn main() {

}
```

Этот текст определяет *Rust-функцию*. Функция `main` - особенная. Это т.н. точка
входа в программу (если читатель уже знаком с C, C++, Java, то тут тоже самое).
`main` - начало всех начал вашей программы. Т.е. это текс значит следующее:
"Объявление функции с именем `main`, у которой нет ни параметров и она ничего не
возвращает во внешнюю среду." Если же у неё были бы параметры, они были бы заключены
в круглые скобки `(` `)`.

Также обратите внимание, что тело функции оборачивают фигурными скобками `{` и `}`.
Эти скобки необходимы для функций. Хорошим стилем считается разместить открывающиеся
фигурные скобки на строке, где объявляется функция.

Внутри функции `main`, находится следующий код:

```rust
    println!("Привет, Мир!");
```

Эта строчка кода выполяет всю работу в этой маленькой программе: печатает текст на экран.
Есть определённые стилистические уточнения. Первое, для написания кода
на Rust используется четыре пробела вместо символа табуляции.

Второй важной частью является `println!`. Вызывается макрос, таким образом в Rust реализуется метапрограммирование. Обратите внимание, что в конце слова `println`
стоит восклицательный знак `!`.
Мы обсудим макросы Rust более подробно в приложении E, но сейчас вам нужно знать, что
если вы увидите `!` это означает, что вы вызываете макрос вместо обычной функции.

Далее, в круглых скобках находится текст `"Привет, Мир!"` являющийся *строкой*.
Этот текст передаётся макросу `println!` как входные
данные. Далее, макрос выполняет печать в строке терминала данный текст. Достаточно
легко!

Строка кода заканчивается символом точки с запятой `;`. Символ информирует о том, что выражение
окончено и можно напечатать другое. Большинство строк кода Rust заканчиваются с `;`.

### Компиляция и Запуск - это два различных этапа работы

В разделе "Написание и Запуск Rust программ" было показано, как запустить
созданную программу. Сейчас мы постараемся объяснить каждый шаг.

Прежде чем запустить программму, необходимо скомпилировать её. Вы можете использовать
компилятор Rust, введя команду `rustc` и указав имя исходного файла:

```shell
$ rustc main.rs

```

Если вы программист на C или C++, вы заметите, что это похоже на `gcc` или `clang`.
После успешной компиляции, Rust должен создать двоичный исполняемый файл, который
можно увидеть в Linux или OSX, введя команду `ls` в оболочке:

```shell
$ ls
main  main.rs
```

В Windows:

```cmd
> dir /B %= опция /B позволяет отображать только файлы =%
main.exe
main.rs
```

В списке находятся два файла: файл с исходным кодом программы *.rs* и бинарный
файл (*main.exe* в Windows, *main* на других опрационных системах). Осталось только
запустить *main* или *main.exe*:

```shell
$ ./main  # or .\main.exe на Windows
```

Если бы в исходном коде *main.rs* в входных параметрах макроса был введён текст
“Hello, world!”, то в терминале вы бы увидели `Hello, world!`.

Если у Вас есть опыт программирования на динамических языках, таких как
Ruby, Python или JavaScript то вас, наверное, удивит необходимсть разделения
компиляции и выполнения программ. В составе утилит Rust есть [Ahead-of-Time](AOT)
 компилятор. Он позволяет создавать автономный бинарный файл, которые может быть
 потом использован там, где нет Rust утилит. Это весьма удобно, как для разработчиков
 программного обеспечения, так и для пользователей. Динамические компилирумые
 программы лишены такой возможности.

[Ahead-of-Time]: https://ru.wikipedia.org/wiki/AOT-%D0%BA%D0%BE%D0%BC%D0%BF%D0%B8%D0%BB%D1%8F%D1%86%D0%B8%D1%8F

Компиляция с помощью `rustc` - подходит только для простых программ и по мере
расширения вашего проекта вы хотите управлять всеми параметрами и легко делиться
кодом с другими людьми. Далее, мы познакомим вас с инструментом `Cargo`,
который поможет писать программы на Rust.

## Привет, Cargo!

Cargo - это система управления пакетами для разработки программ на Rust. Удобство
её использования оценили программисты Rust. Cargo позволяет упростить процесс
разработки. Например, Сargo поможет скомпилировать программу из исходного кода,
скачать требуемые библиотеки для вашего проекта. В терминах языка программирования
Rust внешние библиотеки называются *зависимостями* (*dependencies*).

Такая простая программа, которую мы написали не имеет зависимостей. Поэтому,
Cargo понадобиться нам только для компиляции. Когда вы напишите
более сложную программу на Rust, то весь функционал Cargo,
который помогает добавить зависимости в инфраструктуру вашего проекта, будет весьма
кстати.

Поскольку большинство Rust проектов использует Cargo
мы предположим, что и вам его функционал придётся по вкусу и будет удобен. Всё что
вам нужно для его использования идёт в комплекте с компилятором и другими утилитами.
Для того, чтобы проверить правильно ли установлен Cargo, введите в терминале
следующую команду:

```shell
$ cargo --version
cargo 0.21.0
```

Если будет напечатана версия программы - Cargo скорее всего работает. А если
программа `cargo` не найдена - пожалуйста, постарайтесь устранить проблемы установки
(возможно, Вам понадобиться установить Cargo с помощью разлиных способов, которые приведены на
сайте [doc.crates.io].

[doc.crates.io]: http://doc.crates.io/

### Создание Cargo проекта

Создадим проект используя Cargo! Думаю, что он будет отличаться от того проекта,
что был нами создан ранее. Перейдите в директорию с проектами.

Linux и Mac:

```shell
$ cd ~/projects
```

Windows:

```cmd
> cd %USERPROFILE%\projects
```

Далее введём следующую команду:

```shell
$ cargo new hello_cargo --bin
$ cd hello_cargo
```

Мы передали аргумент `--bin` в команду `cargo new`, потому что наша цель создать исполняемое приложение, а не библиотеку.
`hello_cargo` - это название нашего нового Rust проекта.

Если мы просмотрим список созданных файлов, то мы увидим что Cargo создал
два файла и одну директорию: *Cargo.toml*,*.gitignore*, *src*.
Внутри директории *src* находится файл *main.rs*. По умолчанию Cargo оснастил папку нашего проекта файлом
*.gitignore* - это служебный файл git хранилища. Вы можете создать проект из без
инициализации git хранилища (или какого-либо иного вида системы контроля версий файлов),
если воспользуйтесь флагом `--vcs` при создании нового проекта:

Внутри текстового файла *Cargo.toml* следующее содержание:

<span class="filename">Имя файла: Cargo.toml</span>

```toml
[package]
name = "hello_cargo"
version = "0.1.0"
authors = ["Your Name <you@example.com>"]

[dependencies]
```

Это файл формата [*TOML*][toml]<!-- ignore --> (Tom’s Obvious, Minimal
Language). Формат TOML очень похож на INI, но он имеет свои специфические особенности.

[toml]: https://github.com/toml-lang/toml

На первой строке расположен заголовок секции`[package]`. Далее следует описание пакета.
По мере усложнения проекта, в данный файл будут добавлять другие секции.

Следующие строки - это строки описания пакета: имя, версия, авторы.
Если в строке у Вас написано имя компьютера, значит Вы ещё не до конца настроили
систему для работы с Cargo (Cargo не может считать информацию о вас, а также недоступны
другие опции работы с git).

Последняя строка `[dependencies]` - это заголовок секции *crates* (так называются
пакеты в терминах языка программирования Rust). Этот список содержит описание зависимостей
вашего проекта и предоставляет Cargo функционалу необходимую информацию для загрузки
и компиляции. Нам не нужны никакие пакеты для этого проекта, но мы будем использовать
их в игре следующей главы.

Теперь перейдём к рассмотрению содержания файла *src/main.rs*:

<span class="filename">Имя файла: src/main.rs</span>

```rust
fn main() {
    println!("Hello, world!");
}
```

Как видите, тут уже есть код программы, который мы писали ранее.
Отличия нашего предыдущего проекта от генерируемого Cargo следующие:
- Наш код расположен в директории *src*.
- Есть файл конфигурации *Cargo.toml*

В корневой папке проекта могут также содержаться файлы README, CONTRIBUTING, LICENSE,
файлы конфигурации, а также всё что угодно не относящаяся к исходному коду программы.
Концепция структуры хранения данных Cargo позволяет унифицировать структуру Rust
проектов, что делает их понятными для изучения и развития. Такие проекты потенциально
могут быть сколько угодно сложными и ёмкими. Cargo поможет со всеми ими справиться.

Если вы создали проект без использования Cargo, то можно преобразовать его в проект
самостоятельно, переместив код в директорию *src* и создав файл *Cargo.toml*.

### Сбор и запуск Cargo проектов

Теперь давайте разберёмся, чем отличается сбор и запуск проекта с Cargo.
Для этого введите следующие команды:

```shell
$ cargo build
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
```

Результат - создание бинарного файла в директории *target/debug/hello_cargo*
(*target\\debug\\hello_cargo.exe* в Windows). Проверим работу созданного файла:

```shell
$ ./target/debug/hello_cargo # or .\target\debug\hello_cargo.exe on Windows
Hello, world!
```

Отлично! Если всё в порядке, то в терминале напечатается "Hello, world!".

Обратите внимание, что команда `cargo build` при первом её запуске в текущем
проекте создаёт файл *Cargo.lock*. Этот файл содержит следующий текст:

<span class="filename">Имя файла: Cargo.lock</span>

```toml
[root]
name = "hello_cargo"
version = "0.1.0"
```

Файл *Cargo.lock* необходим для отслеживания зависимостей вашего проекта.
Так как текущей проект не содержит зависимостей, данный файл не содержит данных
для отслеживания зависимостей. По мере усложнения проекта Cargo будет отслеживать
зависимости (данный файл будет заполнять необходимой для этого информацией).

Для компиляции и запуска программы воспользуйтесь командой `cargo run`:

```shell
$ cargo run
     Running `target/debug/hello_cargo`
Hello, world!
```

Обратите внимание, что в командной сроке не было напечатано ничего о компиляции.
Cargo умеет отслеживать состояние исходных файлов проекта. Так как изменений не
было - следовательно, перекомпиляция не нужна. Если бы были изменения
в исходном коде, Cargo перекомпилировал проект до его запуска и вы бы
увидели следующее: 

```shell
$ cargo run
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
     Running `target/debug/hello_cargo`
Hello, world!
```

Подведём итоги:
- Вместо использования `rustc`, собирайте проект с помощью `cargo build`.
- Cargo размещает результат сборки в директорию *target/debug*.

Другое преимущество Cargo состоит в том, что команды являются кроссплатформенными,
поэтому на данный момент мы больше не будем предоставлять конкретных инструкций для
Linux и Mac в сравнении Windows.

### Сборка готовых (оптимизированных) Rust-приложений

Когда проект готов к релизу, можно воспользоваться командой
`cargo build --release`.

Эта команда скомпилирует и оптимизирует вашу программу. В папке *target/release*
будет создан бинарный файл. Все оптимизации позволят программе работать быстрее.
Обратная сторона подобной операции - более длительное время компиляции. Поэтому
существуют две команды компиляции - для разработки и для финальных версий.
Для проверки производительности ваших программ мы рекомендуем использовать
бинарные файлы, которые были получены путем компиляции и оптимизации (которые
сохраняются в директории *target/release*).

### Cargo as Convention Cargo-конвенции

Конечно, простые примеры не могут раскрыть все возможностей, которые предоставляет
Cargo по сравнение с прямой работой с компилятором. Для более сложных проектов
концепции Cargo - это проверенный временем стиль разработки. Привыкайте к хорошему
стилю работы даже с простыми проектами!
Вы можете начать работу практически со всеми проектами Rust, со следующих командами:

```shell
$ git clone someurl.com/someproject
$ cd someproject
$ cargo build
```

> Если вы хотите подробнее узнать о Cargo, ознакомьтесь с
> [официальным руководством], которое охватывает всю функциональность.

[официальным руководством]: http://doc.crates.io/guide.html

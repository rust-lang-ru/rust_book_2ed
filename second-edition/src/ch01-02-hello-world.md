## Hello, World!

Итак, когда Rust уже установлен, можно приступать к написанию вашей первой программы.
[По традиции], (а точнее с 1978 года, когда вышла в свет первое издания [книги о Си])
напишем небольшую программу, которая напечатает "Привет, Мир!" в строке вывода.

[По традиции]: https://ru.wikipedia.org/wiki/Hello,_world!
[книги о Си]: https://ru.wikipedia.org/wiki/%D0%AF%D0%B7%D1%8B%D0%BA_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F_%D0%A1%D0%B8_(%D0%BA%D0%BD%D0%B8%D0%B3%D0%B0)

> Примечание: Эта книга предполагает базовое знакомство с командной строкой.
> Сам Rust не предъявляет особых требований к редакторам, инструментарию
> или месту хранения кода, поэтому, если вы предпочитаете IDE
> командной строке - используйте свою любимую интегрированную среду разработки.

### Создание директории проекта

Первым делом создадим директорию для хранения исходных кодов Rust. Это, конечно, не
обязательное условие для программировании на Rust, но для удобства нашей работы
это будут лучшим решением.

Итак, приступим. Создадим папку *projects* и далее будем создавать проекты Rust
в этой директории. Для этого откроем эмулятор терминала и введём следующие команды:

Linux и Mac:

```shell
$ mkdir ~/projects
$ cd ~/projects
$ mkdir hello_world
$ cd hello_world
```

Windows CMD:

```cmd
> mkdir %USERPROFILE%\projects
> cd %USERPROFILE%\projects
> mkdir hello_world
> cd hello_world
```

Windows PowerShell:

```powershell
> mkdir $env:USERPROFILE\projects
> cd $env:USERPROFILE\projects
> mkdir hello_world
> cd hello_world
```

### Написание и запуск первой программы

Далее, создадим текстовый файл и назовём его *main.rs*. Все файлы исходного кода Rust имеют расширение *.rs*. Если в имени файла несколько слов, используйте нижнее
подчёркивание для их разделения. Например, пишите *hello_world.rs* вместо
*helloworld.rs*.

Теперь откроем файл *main.rs* для редактирования и введём следующие сроки кода:

<span class="filename">Имя файла: main.rs</span>

```rust
fn main() {
    println!("Привет, Мир!");
}
```

Сохраним файл и вернёмся в окно терминала. На Linux или macOS, введём
следующие команды:

```shell
$ rustc main.rs
$ ./main
Привет, Мир!
```

На Windows, используем `.\main.exe` вместо `./main`:

```cmd
> rustc main.rs
> .\main.exe
Привет, Мир!
```

Независимо от вашей операционной системы, вы должны увидеть строку `Привет, мир!`,
напечатанную в терминале. Поздравляем, если получилось! Вы официально написали программу на Rust.
Вы - программист на Rust! Добро пожаловать!

### Структура программы на Rust

Теперь, давайте разберёмся, как же работает ваша новая программа "Привет, мир!".
Для начала, разберем исходный код:

```rust
fn main() {

}
```

Этот текст определяет функцию на *Rust*. Функция `main` - особенная. Это т.н. точка
входа в программу (если читатель уже знаком с C, C++, Java, то тут тоже самое).
`main` - начало всех начал вашей программы. Т.е. это текст значит следующее:
"Объявление функции с именем `main`, которая не принимает параметров и ничего не возвращает."
Если же у неё были бы параметры, они были бы заключены в круглые скобки `(` `)`.

Также обратите внимание, что тело функции оборачивают фигурными скобками `{` и `}`.
Rust требует их вокруг тела каждой функции. Хорошим стилем считается разместить открывающиеся фигурные скобки на строке, где объявляется функция.

Внутри функции `main` находится следующий код:

```rust
    println!("Привет, Мир!");
```

Эта строчка кода выполняет всю работу в этой маленькой программе: печатает текст на экран.
Есть определённые стилистические уточнения. Во-вторых, для написания кода
на Rust используется четыре пробела вместо символа табуляции.

Второй важной частью является `println!`. Так выглядит вызов макросов, с помощью которых в Rust реализовано метапрограммирование. Обратите внимание, что в конце слова `println`
стоит восклицательный знак `!`.
Мы обсудим макросы Rust более подробно в приложении E, но сейчас вам нужно знать, что
если вы увидите `!` это означает, что вы вызываете макрос вместо обычной функции.

Далее, в круглых скобках находится *строка* `"Привет, мир!"` являющийся *строкой*.
Этот текст передаётся макросу `println!` как входные
данные. Далее, макрос печатает данный текст в терминале. Достаточно
легко!

Строка кода заканчивается символом точки с запятой `;`. Символ информирует о том, что выражение
окончено и можно напечатать другое. Большинство строк кода Rust заканчиваются на `;`.

### Компиляция и запуск - это два различных этапа работы

В разделе "Написание и Запуск Rust программ" было показано, как запустить
созданную программу. Сейчас мы постараемся объяснить каждый шаг.

Прежде чем запустить программу, необходимо скомпилировать её. Вы можете использовать
компилятор Rust, введя команду `rustc` и указав имя исходного файла:

```shell
$ rustc main.rs

```

Если вы программист на C или C++, вы заметите, что это похоже на `gcc` или `clang`.
После успешной компиляции, Rust должен создать двоичный исполняемый файл, который
можно увидеть в Linux или OSX, введя команду `ls` в оболочке:

```shell
$ ls
main  main.rs
```

В Windows:

```cmd
> dir /B %= опция /B позволяет отображать только файлы =%
main.exe
main.rs
```

В списке находятся два файла: файл с исходным кодом программы *.rs* и бинарный
файл (*main.exe* в Windows, *main* на других операционных системах). Осталось только
запустить *main* или *main.exe*:

```shell
$ ./main  # or .\main.exe на Windows
```

Если бы в исходном коде *main.rs* в входных параметрах макроса был введён текст
“Hello, world!”, то в терминале вы бы увидели `Hello, world!`.

Если у вас есть опыт программирования на динамических языках, таких как
Ruby, Python или JavaScript, то вас удивит необходимость разделения
компиляции и запуска программ. В составе утилит Rust есть [Ahead-of-Time](AOT)
компилятор. Это позволяет скомпилировать программу, поделиться ей с кем-то и запустить без необходимости установки Rust. Это весьма удобно, как для разработчиков программного обеспечения, так и для пользователей. Всё это является компромиссом в дизайне языка.

[Ahead-of-Time]: https://ru.wikipedia.org/wiki/AOT-%D0%BA%D0%BE%D0%BC%D0%BF%D0%B8%D0%BB%D1%8F%D1%86%D0%B8%D1%8F

Компиляция с помощью `rustc` подходит только для простых программ и по мере
расширения вашего проекта вы хотите управлять всеми параметрами и легко делиться
кодом с другими людьми. Далее мы познакомим вас с инструментом `Cargo`,
который поможет писать программы на Rust.

## Привет, Cargo!

Cargo - это система управления пакетами для разработки программ на Rust. Удобство
её использования оценили программисты на Rust. Cargo позволяет упростить процесс
разработки. Например, Cargo поможет скомпилировать программу из исходного кода,
скачать требуемые библиотеки для вашего проекта. В терминах языка программирования
Rust внешние библиотеки называются *зависимостями* (*dependencies*).

Простая программа, которую мы написали, не имеет зависимостей. Поэтому,
Cargo понадобится нам только для компиляции. Когда вы напишете
более сложную программу на Rust, то весь функционал Cargo,
который помогает добавить зависимости в инфраструктуру вашего проекта, будет весьма
кстати.

Поскольку большинство на Rust проектов использует Cargo,
мы предположим, что и вам его функционал придётся по вкусу и будет удобен. Всё, что
вам нужно для его использования, идёт в комплекте с компилятором и другими утилитами.
Для того, чтобы проверить правильно ли установлен Cargo, введите в терминале
следующую команду:

```shell
$ cargo --version
cargo 0.21.0
```

Если будет напечатана версия программы - Cargo скорее всего работает. А если
программа `cargo` не найдена - пожалуйста, постарайтесь устранить проблемы установки
(возможно, Вам понадобится установить Cargo с помощью одного из способов, приведённых на
сайте [doc.crates.io].

[doc.crates.io]: http://doc.crates.io/

### Создание проекта Cargo

Создадим проект с Cargo! Думаю, что он будет отличаться от того проекта,
что был нами создан ранее. Перейдите в директорию с проектами.

Linux и Mac:

```shell
$ cd ~/projects
```

Windows:

```cmd
> cd %USERPROFILE%\projects
```

Далее введём следующую команду:

```shell
$ cargo new hello_cargo --bin
$ cd hello_cargo
```

Мы передали аргумент `--bin` в команду `cargo new`, потому что мы хотим создать исполняемый файл, а не библиотеку.
`hello_cargo` - это название нашего нового Rust проекта.

Если мы просмотрим список созданных файлов, то мы увидим, что Cargo создал
два файла и одну директорию: *Cargo.toml*, *.gitignore*, *src*.
Внутри директории *src* находится файл *main.rs*. По умолчанию Cargo оснастил папку нашего проекта файлом
*.gitignore* - это служебный файл системы контроля версий Git. Вы можете создать проект и без инициализации репозитория Git (или какого-либо иного вида системы контроля версий файлов),
если воспользуетесь флагом `--vcs` при создании нового проекта.

Внутри текстового файла *Cargo.toml* следующее содержание:

<span class="filename">Имя файла: Cargo.toml</span>

```toml
[package]
name = "hello_cargo"
version = "0.1.0"
authors = ["Your Name <you@example.com>"]

[dependencies]
```

Это файл формата [*TOML*][toml]<!-- ignore --> (Tom’s Obvious, Minimal
Language). Формат TOML очень похож на INI, но он имеет свои специфические особенности.

[toml]: https://github.com/toml-lang/toml

На первой строке расположен заголовок раздела `[package]`. Далее следует описание пакета.
По мере усложнения проекта, в данный файл будут добавляться другие разделы.

Следующие строки - это строки описания пакета: имя, версия, авторы.
Если в строке у Вас написано имя компьютера, значит Вы ещё не до конца настроили
систему для работы с Cargo (Cargo не может считать информацию о вас, а также недоступны
другие опции работы с git).

Последняя строка `[dependencies]` - это заголовок секции *crates* (так называются
пакеты в терминах языка программирования Rust). Этот список содержит описание зависимостей
вашего проекта и предоставляет Cargo функционалу необходимую информацию для загрузки
и компиляции. Нам не нужны никакие пакеты для этого проекта, но мы будем использовать
их в следующей главе.

Теперь перейдём к рассмотрению содержания файла *src/main.rs*:

<span class="filename">Имя файла: src/main.rs</span>

```rust
fn main() {
    println!("Hello, world!");
}
```

Как видите, тут уже есть код программы, который мы писали ранее.
Отличия нашего предыдущего проекта от генерируемого Cargo следующие:
- Наш код расположен в директории *src*.
- Есть файл конфигурации *Cargo.toml*

В корневой папке проекта могут также содержаться файлы README, CONTRIBUTING, LICENSE,
файлы конфигурации, а также что угодно неотносящееся к исходному коду программы.
Концепция структуры хранения данных Cargo позволяет унифицировать структуру
проектов на Rust, что делает их понятными для изучения и развития. Такие проекты потенциально
могут быть сколько угодно сложными и ёмкими. Cargo поможет со всеми ими справиться.

Если вы создали проект без использования Cargo, то можно преобразовать его в проект
самостоятельно, переместив код в директорию *src* и создав файл *Cargo.toml*.

### Сборка и запуск проектов Cargo

Теперь давайте разберёмся, чем отличается сбор и запуск проекта с Cargo.
Для этого введите следующие команды:

```shell
$ cargo build
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
```

Результат - создание бинарного файла в директории *target/debug/hello_cargo*
(*target\\debug\\hello_cargo.exe* в Windows). Проверим работу созданного файла:

```shell
$ ./target/debug/hello_cargo # или .\target\debug\hello_cargo.exe на Windows
Hello, world!
```

Отлично! Если всё в порядке, то в терминале напечатается "Hello, world!".

Обратите внимание, что команда `cargo build` при первом её запуске в текущем
проекте создаёт файл *Cargo.lock*. Этот файл содержит следующий текст:

<span class="filename">Имя файла: Cargo.lock</span>

```toml
[root]
name = "hello_cargo"
version = "0.1.0"
```

Файл *Cargo.lock* необходим для отслеживания зависимостей вашего проекта.
Так как текущей проект не содержит зависимостей, данный файл не содержит данных
для отслеживания зависимостей. По мере усложнения проекта Cargo будет отслеживать
зависимости (данный файл будет заполняться необходимой для этого информацией).

Для компиляции и запуска программы воспользуйтесь командой `cargo run`:

```shell
$ cargo run
     Running `target/debug/hello_cargo`
Hello, world!
```

Обратите внимание, что в командной сроке не было напечатано ничего о компиляции.
Cargo умеет отслеживать состояние исходных файлов проекта.
Так как изменений не было, перекомпиляция не нужна. Если бы были изменения
в исходном коде, Cargo перекомпилировал бы проект до его запуска и вы бы
увидели следующее: 

```shell
$ cargo run
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
     Running `target/debug/hello_cargo`
Hello, world!
```

Подведём итоги:
- Вместо использования `rustc`, собирайте проект с помощью `cargo build`.
- Cargo размещает результат сборки в директории *target/debug*.

Другое преимущество Cargo состоит в том, что команды являются кроссплатформенными,
поэтому на данный момент мы больше не будем предоставлять конкретных инструкций для
Linux и Mac с Windows.

### Сборка готовых (оптимизированных) приложений на Rust

Когда проект готов к выпуску, можно воспользоваться командой
`cargo build --release`.

Эта команда скомпилирует и оптимизирует вашу программу. В папке *target/release*
будет создан бинарный файл. Все оптимизации позволят программе работать быстрее.
Обратная сторона подобной операции - более длительное время компиляции. Поэтому
существуют две команды компиляции - для разработки и для финальных версий.
Для проверки производительности ваших программ мы рекомендуем использовать
бинарные файлы, которые были получены путем компиляции и оптимизации (которые
сохраняются в директории *target/release*).

### Cargo конвенции

Конечно, простые примеры не могут раскрыть все возможностей, которые предоставляет
Cargo по сравнение с прямой работой с компилятором. Для более сложных проектов
концепции Cargo - это проверенный временем стиль разработки. Привыкайте к хорошему
стилю работы даже с простыми проектами!
Вы можете начать работу практически со всеми проектами Rust, со следующих команд:

```shell
$ git clone someurl.com/someproject
$ cd someproject
$ cargo build
```

> Если вы хотите подробнее узнать о Cargo, ознакомьтесь с
> [официальным руководством], которое охватывает всю функциональность.

[официальным руководством]: http://doc.crates.io/guide.html
